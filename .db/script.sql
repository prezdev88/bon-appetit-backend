-- Usuarios de la app
CREATE TABLE IF NOT EXISTS app_user (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id_number    VARCHAR(8) NOT NULL UNIQUE,
  name      VARCHAR(120)       NOT NULL,
  enabled   BOOLEAN            NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ       NOT NULL DEFAULT NOW()
);

-- Roles (evitamos palabra reservada ROLE -> app_role)
CREATE TABLE IF NOT EXISTS app_role (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name      VARCHAR(80)        NOT NULL,
  CONSTRAINT uq_app_role_name UNIQUE (name)
);

-- Relación N:M usuario-rol
CREATE TABLE IF NOT EXISTS user_role (
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  PRIMARY KEY (user_id, role_id),
  CONSTRAINT fk_user_role_user FOREIGN KEY (user_id) REFERENCES app_user(id) ON UPDATE RESTRICT ON DELETE CASCADE,
  CONSTRAINT fk_user_role_role FOREIGN KEY (role_id) REFERENCES app_role(id) ON UPDATE RESTRICT ON DELETE RESTRICT
);
-- Índices recomendados para FKs (Postgre no los crea automáticamente)
CREATE INDEX IF NOT EXISTS ix_user_role_user   ON user_role(user_id);
CREATE INDEX IF NOT EXISTS ix_user_role_role   ON user_role(role_id);

-- Mesas del comedor
CREATE TABLE IF NOT EXISTS dining_table (
  id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  number  INTEGER NOT NULL,
  CONSTRAINT uq_dining_table_number UNIQUE (number)
);

-- Productos
CREATE TABLE IF NOT EXISTS product (
  id       BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name     VARCHAR(150)        NOT NULL,
  price    NUMERIC(12,2)       NOT NULL CHECK (price >= 0),
  enabled  BOOLEAN             NOT NULL DEFAULT TRUE,
  CONSTRAINT uq_product_name UNIQUE (name)
);

-- ─────────────────────────────────────────────────────────────────────────────
-- Órdenes y detalle
-- ─────────────────────────────────────────────────────────────────────────────

-- Orden de comida
CREATE TABLE IF NOT EXISTS food_order (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  table_id   BIGINT        NOT NULL,
  created_by BIGINT        NOT NULL,
  total      NUMERIC(12,2) NOT NULL DEFAULT 0 CHECK (total >= 0),
  created_at TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  CONSTRAINT fk_food_order_table  FOREIGN KEY (table_id)   REFERENCES dining_table(id) ON UPDATE RESTRICT ON DELETE RESTRICT,
  CONSTRAINT fk_food_order_user   FOREIGN KEY (created_by) REFERENCES app_user(id)     ON UPDATE RESTRICT ON DELETE RESTRICT
);
CREATE INDEX IF NOT EXISTS ix_food_order_table_id   ON food_order(table_id);
CREATE INDEX IF NOT EXISTS ix_food_order_created_by ON food_order(created_by);
CREATE INDEX IF NOT EXISTS ix_food_order_created_at ON food_order(created_at);

-- Historial de estados de una orden
-- (En tu diagrama la tabla `order_status` no mostraba la FK a la orden; la incluyo aquí
--  como `order_id` para que el historial quede asociado a cada `food_order`.)
CREATE TABLE IF NOT EXISTS order_status (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id    BIGINT        NOT NULL,
  status      VARCHAR(40)   NOT NULL,           -- ej: 'CREATED','SENT','PREPARING','READY','DELIVERED','CANCELLED'
  changed_at  TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  changed_by  BIGINT        NOT NULL,
  CONSTRAINT fk_order_status_order  FOREIGN KEY (order_id)  REFERENCES food_order(id) ON UPDATE RESTRICT ON DELETE CASCADE,
  CONSTRAINT fk_order_status_user   FOREIGN KEY (changed_by) REFERENCES app_user(id)  ON UPDATE RESTRICT ON DELETE RESTRICT
);
CREATE INDEX IF NOT EXISTS ix_order_status_order_id  ON order_status(order_id);
CREATE INDEX IF NOT EXISTS ix_order_status_changed_by ON order_status(changed_by);
CREATE INDEX IF NOT EXISTS ix_order_status_changed_at ON order_status(changed_at);

-- Detalle de productos por orden
CREATE TABLE IF NOT EXISTS order_product (
  order_id    BIGINT        NOT NULL,
  product_id  BIGINT        NOT NULL,
  quantity    INTEGER       NOT NULL CHECK (quantity > 0),
  subtotal    NUMERIC(12,2) NOT NULL CHECK (subtotal >= 0),
  notes       TEXT          NULL,
  created_by  BIGINT        NOT NULL,
  created_at  TIMESTAMPTZ   NOT NULL DEFAULT NOW(),
  PRIMARY KEY (order_id, product_id),
  CONSTRAINT fk_order_product_order   FOREIGN KEY (order_id)   REFERENCES food_order(id) ON UPDATE RESTRICT ON DELETE CASCADE,
  CONSTRAINT fk_order_product_product FOREIGN KEY (product_id) REFERENCES product(id)    ON UPDATE RESTRICT ON DELETE RESTRICT,
  CONSTRAINT fk_order_product_user    FOREIGN KEY (created_by) REFERENCES app_user(id)   ON UPDATE RESTRICT ON DELETE RESTRICT
);
CREATE INDEX IF NOT EXISTS ix_order_product_product_id ON order_product(product_id);
CREATE INDEX IF NOT EXISTS ix_order_product_created_by ON order_product(created_by);

-- Opcional: mantener coherencia total = suma de subtotales (puedes usar trigger más adelante)
-- Aquí solo añadimos una restricción blanda: subtotal >= quantity * 0.
-- Un trigger AFTER INSERT/UPDATE en order_product podría recalcular `food_order.total`.

-- ─────────────────────────────────────────────────────────────────────────────
-- Semillas mínimas (opcional)
-- ─────────────────────────────────────────────────────────────────────────────
INSERT INTO app_role(name) VALUES ('ADMIN') ON CONFLICT DO NOTHING;
INSERT INTO app_role(name) VALUES ('WAITER') ON CONFLICT DO NOTHING;


SELECT * from app_user;